;replace.asm
 
 
       MAX_SIZE_FOR_ENTERED_WORD = CHAR_ON_LINE - 13
 
 
       macro    SetColorUI color {
       mov      byte [PrintToEmdStr.Color],color
       }
 
 
       macro    printToScr Str {
       local    .ok, .msg
       mov      esi,.msg
       call     PrintToEmdStr
       jmp      .ok
.msg db Str
db 0
.ok:
       }
 
       macro    SetcursorToLine num {
       mov      eax,dword CHAR_ON_LINE*num ;set cursor to line 2
       call     SetPos
       }
 
       macro    SetcursorToNewLine {
       local    .ok, .l1, .ok2
       pusha
       call     GetPos
 
.l1:
       test     eax,eax
       jz       .ok
       cmp      eax,dword CHAR_ON_LINE
       jb       .ok
       sub      eax,dword CHAR_ON_LINE
       jmp      .l1
 
.ok:
       push     ax
 
       call     GetPos
       pop      bx
       sub      ax,bx
       add      ax,CHAR_ON_LINE
       cmp      ax,word CHAR_ON_LINE*24
       jnz      .ok2
 
       call     shiftPage ;----
       mov      eax,dword CHAR_ON_LINE*23
.ok2:
       call     SetPos
       popa
       }
 
 
ReplaceWord: ;inc/replace.asm
 
       macro    pushXY {
       push     ax
 
;for undercur.asm
       call     GetChAdr
       mov      dword [.ptrCh],eax
       call     GetLnAdr
       mov      dword [.ptrLn],eax
       mov      al,[x]
       mov      ah,[y]
       mov      [.x],al
       mov      [.y],ah
       pop      ax
       }
 
       macro    popXY {
       push     ax
       mov      al,[.x]
       mov      ah,[.y]
 
       mov      [x],al
       mov      [y],ah
       pop      ax
       }
 
 
       macro    Hidecursor {
       xor      ax,ax
       mov      [x],al
       mov      [y],al
;hide cursor
       mov      ah,02h ;- bios servis
       mov      bh,0
       mov      dh,25
       mov      dl,25
       int      10h
       }
 
       pushXY
       mov      [SetcursorBios.fVisible], byte 1
       call     cls
       SetcursorToLine 0
       SetColorUI 7
printToScr 'enter word1: '
       call     EnterWord ;return ax=ptr to entered string
       jnc      .Word2
 
.Wrong:
       SetColorUI 7
       printToScr ' something wrong '
       call     WaitPressAnyKey
       popXY
       ret      ;- - - - - - - - - - - - - - exit[1]
 
.Word2:
       SetColorUI 7
 
       macro    saveInputStr ptrMem {
       local    .llllo
       mov      si,ax
       mov      di,word ptrMem
.llllo:
       mov      al,byte [si]
       mov      [di],byte al
       inc      di
       inc      si
       test     al,al
       jnz      .llllo
       }
 
       saveInputStr .str1
       SetcursorToLine 1
       SetColorUI 7
printToScr 'enter word2: '
       call     EnterWord ;return ax=ptr to entered string
       jc       .Wrong
       SetColorUI 7
 
       saveInputStr .str2
 
       SetcursorToLine 2
 
       mov      [SetcursorBios.fVisible], byte 0
       Hidecursor
 
       SetColorUI 7
       mov      ax ,word .str1
       mov      bx ,word .str2
       call     FindAndReplace ;ret ecx =num of reps
 
       push     cx
       shr      ecx,16
       push     cx
 
;print info
       SetcursorToNewLine
 
printToScr 'replaces:'
 
       pop      ax
       shl      eax,16
       pop      ax
 
       call     Bin2AsciiDec ;esi=str
macro CrrctEsiFrFrstZrPrnt {
local .delCharZero, .okDelZ
mov ecx,11
.delCharZero:
        dec ecx
jz .okDelZ
mov al,[esi]
inc esi
cmp al,'0'
jnz .okDelZ
jz .delCharZero
.okDelZ:
dec esi
       call     PrintToEmdStr
call GetPos
mov edx,eax
       mov      eax, 0x007200720
       mov      ecx,dword 10
       call     FillVideoPage
 
}
 CrrctEsiFrFrstZrPrnt
 
;       call     PrintToEmdStr
 
       printToScr ' Press any key.. '
       call     WaitPressAnyKey
       popXY
       ret      ;- - - - - - - - - - - - - - exit[2]
 
.x db 0
.y db 0
 
.ptrCh dd 0
.ptrLn dd 0
 
 
;buffers for input strings
.str1 rb MAX_SIZE_FOR_ENTERED_WORD
.str2 rb MAX_SIZE_FOR_ENTERED_WORD
 
 
;ecx=size,esi=ptr to string
ChangeColorUIword:
       mov      dword [.numOfOks],0
 
       test     ecx,ecx
       jnz      .work
       SetColorUI 7
       ret
.work:
       mov      dword [.saveEcx],ecx
       mov      dword [.saveEsi],esi
 
       mov      edi,dword [StartMemory]
       mov      edx,dword [SizeTextFormatted]
       mov      bl,byte [esi]
.l1ecx:
       mov      ecx,dword [.saveEcx]
       mov      esi,dword [.saveEsi]
 
.l1:
       mov      al,byte [edi]
       inc      edi
       cmp      al,bl
       jz       .match1
       dec      edx
       jnz      .l1
 
       cmp      dword [.numOfOks],0
       jz       .nothing
       SetColorUI 7
       ret
 
.nothing:
       SetColorUI 8
       ret
 
.match1:
       dec      ecx
       jz       .ok
       inc      esi
       mov      al,byte [edi]
       cmp      al,byte [esi]
       jnz      .l1ecx
       inc      edi
       jmp      .match1
 
.ok:
       inc      dword [.numOfOks]
       cmp      edx,1
       ja       .l1ecx
       SetColorUI 7
       ret
.numOfOks dd 0
.saveEcx dd 0
.saveEsi dd 0
 
 
EnterWord:
       call     GetPos
       mov      [.posToStartCursor],eax
 
mov edx,eax
       mov      eax, 0x007200720
       mov      ecx,dword 10
       call     FillVideoPage
 
macro dellllll {
       mov      esi,dword spacesString
       call     PrintToEmdStr
       mov      eax, [.posToStartCursor]
       call     SetPos
                }
.NextKey:
 
 
       mov      eax, dword [ChangeColorUIword.numOfOks]
       mov      edx,dword [.posToStartCursor]
       mov      cx,word [.iTop]
       shl      ecx,16
       mov      cx,word [.i]
 
       call     PrintNumOfFindes
 
 
       macro    ChangeColorLive {
       pusha
       mov      esi,dword .EnteredString
       xor      ecx,ecx
       mov      cx,word [.iTop]
       call     ChangeColorUIword
       popa
       }
 
;it is macros for enter char to buffer
       macro    CharEnterToUserString {
       local    .l1,.macroExit, .work
       push     ax
       call     SavePos
 
       mov      bx,word .EnteredString
       mov      di,bx
       add      bx,word [.i]
       add      di,word [.iTop]
;bx=current pos , di = end pos
 
       cmp      bx,di
       jae      .macroExit
 
       cmp      word [.iTop],MAX_SIZE_FOR_ENTERED_WORD-5
       jz       .macroExit
       jb       .work
       pop      ax
       jmp      .errorEnterWord
 
.work:
       inc      word [.iTop]
;inc word [.i] (-jmp .incX)
 
       mov      al,byte [bx]
       pop      dx
       mov      byte [bx],dl ;enter new char
 
       inc      bx
       inc      di
.l1:
       mov      dl,byte [bx]
       mov      byte [bx],al
       inc      bx
 
       mov      al,byte [bx]
       mov      byte [bx],dl
       inc      bx
 
       cmp      bx,di
       jb       .l1
 
       mov      ax,word [.i]
       push     ax
       mov      ax,word [.iTop]
       push     ax
 
       call     .PutNewStringCall
       call     RestorePos
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
 
       pop      ax
       mov      word [.iTop],ax
       pop      ax
       mov      word [.i],ax
       jmp      .incx
 
.macroExit:
       pop      ax
       }
 
 
       call     .GetKey
;-----cursor keys-------
       cmp      ah,4Bh
       je       .decx
 
       cmp      ah,4Dh
       je       .incx
 
       cmp      ah,48h
       je       .decy
 
       cmp      ah,50h
       je       .incy
;------
 
       cmp      ah,83 ;del
       je       .del
 
 
       cmp      ah,1;esc
       je       .close
 
       cmp      ah,14 ;bsp
       jz       .backspace
 
       cmp      ah,28 ;enter
       jz       .KeyEnter
 
       mov      bx,ax
       mov      eax, dword [.ForwardNum]
       cmp      eax,dword MAX_SIZE_FOR_ENTERED_WORD-5
       jz       .NextKey
       mov      ax,bx
 
       cmp      al,32
       jb       .NextKey
 
       CharEnterToUserString
 
       push     ax
       call     .SaveChar
       ChangeColorLive
       pop      ax
       call     PrintToEmd_ASCII_Char
       inc      dword [.ForwardNum]
       jmp      .NextKey
.ForwardNum dd 0
 
 
;-----cursor keys-------
 
.decx:
       dec      dword [.ForwardNum]
 
       call     .SaveCharDecX
       jc       .decXl1
       call     DecX_replace
.decXl1:
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
       jmp      .NextKey ;decx - exit
 
.incx:
       mov      eax, dword [.ForwardNum]
       cmp      eax,dword MAX_SIZE_FOR_ENTERED_WORD-5
       jz       .NextKey
       inc      dword [.ForwardNum]
 
       call     .SaveCharIncX
       jc       .incXl1
       call     IncX_replace
.incXl1:
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
 
       jmp      .NextKey
 
 
;----\
.ReplaceFirstLast:
       mov      al, byte [.invertLastFirstCursor]
       shl      al,7
       test     al,al
       jz       .lastCur
       call     FromCurorFirst ; replace text in buffer - esi = ptr
       inc      byte [.invertLastFirstCursor]
       ret
.lastCur:
       call     FromCurorLast ; replace text in buffer - esi = ptr
       inc      byte [.invertLastFirstCursor]
       ret
.invertLastFirstCursor db 0
;----/
 
 
       macro    CLS_endOfLine {
 
       call     GetPos
       mov      dword [.savePos],eax
.nextSub:
       test     eax,eax
       jz       .macroExit
;calculate num chrs to end of line
       cmp      eax,dword 80
       jb       .ok
       sub      eax,dword 80
       jmp      .nextSub
.ok:
       cmp      ax,80-6
       jae      .macroExit
 
 
       mov      cx,word 80
       sub      cx,ax
       sub      cx,word 5
 
.l01:
       cmp      cx,40
       jbe      .l02
       push     cx
       mov      esi,dword .moreSpaces40
       call     PrintToEmdStr
       pop      cx
       sub      cx,word 40
       jmp      .l01
 
.l02:
       cmp      cx,20
       jbe      .l0
       push     cx
       mov      esi,dword .moreSpaces20
       call     PrintToEmdStr
       pop      cx
       sub      cx,word 20
       jmp      .l02
 
.l0:
       cmp      cx,4
       jbe      .l1
       push     cx
       mov      esi,dword .moreSpaces
       call     PrintToEmdStr
       pop      cx
       sub      cx,word 4
       jmp      .l0
 
.l1:
       push     cx
       mov      al,32
       call     PrintToEmd_ASCII_Char
       pop      cx
       dec      cx
       jnz      .l1
 
       mov      eax,dword [.savePos]
       call     SetPos
       call     SetcursorBios
 
       jmp      .macroExit
.savePos dd 0
.moreSpaces40 db 32,32,32,32,32,32,32,32,32,32
db 32,32,32,32,32,32,32,32,32,32
.moreSpaces20:
db 32,32,32,32,32,32,32,32,32,32
db 32,32,32,32,32,32
.moreSpaces db 32,32,32,32,0
.macroExit:
       }
 
.incy:
;erase buffer
       mov      edi,dword .EnteredString
       mov      ecx,dword MAX_SIZE_FOR_ENTERED_WORD ;size buffer
       shr      ecx,2
       xor      eax,eax
       call     FillMem
 
       mov      esi,dword .EnteredString
       mov      ecx,dword MAX_SIZE_FOR_ENTERED_WORD ;size buffer
       call     .ReplaceFirstLast
 
.PutNewString:
       call     .PutNewStringCall
 
       mov      eax,dword [.posToStartCursor]
       call     GetPosX
       mov      ebx,eax
       call     GetPos
       call     GetPosX
 
       cmp      eax,ebx
       jb       .errorEnterWord
 
       sub      eax,ebx
       mov      dword [.ForwardNum],eax
 
       jmp      .NextKey
 
.PutNewStringCall:
       mov      eax,dword [.posToStartCursor]
       call     SetPos
 
       call     .SaveCharReset
 
       mov      esi,dword .EnteredString
.correctSaveChar:
       mov      al,[esi]
       call     .SaveChar
       jc       .errorEnterWord
       inc      esi
       mov      al,[esi]
       test     al,al
       jnz      .correctSaveChar
 
       ChangeColorLive
 
       mov      esi,.EnteredString
       call     PrintToEmdStr
 
       CLS_endOfLine
       ret
 
 
.decy:
       xor      eax,eax
       call     HistoryReplaces
       mov      esi,eax
       mov      edi,dword .EnteredString
       mov      ecx,MAX_SIZE_FOR_ENTERED_WORD-1
.l13:
       mov      al,[esi]
       mov      [edi],al
       inc      esi
       inc      edi
       dec      ecx
       jz       .ok3
       test     al,al
       jnz      .l13
       jmp      .PutNewString
 
.ok3:
       mov      byte [edi],0
       jmp      .PutNewString
 
 
;-----------------------
.del:
 
       call     SavePos
 
       mov      bx,word .EnteredString
       mov      di,bx
       add      bx,word [.i]
       add      di,word [.iTop]
;bx=current pos , di = end pos
 
       cmp      bx,di
       ja       .errorEnterWord
       jz       .NextKey ;del key exit
 
.delCharUser:
       mov      al,byte [bx+1]
       mov      byte [bx],al
       inc      bx
       cmp      bx,di
       jnz      .delCharUser
 
.delOk: ;exit del all
       mov      al,32
       mov      byte [bx],al
 
       cmp      word [.iTop],0
       jz       .NextKey
 
       dec      word [.iTop]
 
       mov      ax,word [.i]
       push     ax
       mov      ax,word [.iTop]
       push     ax
 
       call     .PutNewStringCall
       call     RestorePos
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
 
       pop      ax
       mov      word [.iTop],ax
       pop      ax
       mov      word [.i],ax
       jmp      .NextKey ;del key exit
 
 
.backspace:
       call     SavePos
 
       mov      bx,word .EnteredString
       mov      di,bx
       cmp      word [.i],0
       jz       .NextKey
 
       add      bx,word [.i]
       add      di,word [.iTop]
;bx=current pos , di = end pos
 
       cmp      bx,di
       ja       .errorEnterWord
 
       dec      bx
.shiftChBackspace:
       mov      al,byte [bx+1]
       mov      byte [bx],al
       inc      bx
       cmp      bx,di
       jnz      .shiftChBackspace
 
       mov      al,0;32 ;5%
       mov      byte [bx],al
 
       cmp      word [.iTop],0
       jz       .NextKey
 
       dec      word [.iTop]
 
       mov      ax,word [.i]
       push     ax
       mov      ax,word [.iTop]
       push     ax
 
       call     .PutNewStringCall
       call     RestorePos
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
 
       pop      ax
       mov      word [.iTop],ax
       pop      ax
       mov      word [.i],ax
       jmp      .decx ;bcs key exit
 
.close:
.errorEnterWord:
       stc
       ret      ;-----------------------exit1
 
.KeyEnter:
       xor      ax,ax
       call     .SaveChar
       jc       .errorEnterWord
       mov      bx,word .EnteredString
       mov      al,byte [bx]
       test     al,al
       jc       .errorEnterWord
       mov      eax,dword .EnteredString
       call     HistoryReplaces
 
;-del counter\
       mov     edx,dword [.posToStartCursor]
add edx,80
       mov      eax, 0x007200720 ;2 spaces
       mov      ecx,dword 5 ;10 pos
       call     FillVideoPage
;-del counter/
 
       mov      eax,dword .EnteredString
       clc
       ret      ;-----------------------exit2
 
.SaveCharIncX:
       push     ax
       mov      ax,word [.i]
       cmp      ax,word [.iTop]
       jz       .SaveCharI
       inc      word [.i]
       pop      ax
       clc
       ret
.SaveCharI:
       pop      ax
       stc
       ret
 
 
.SaveCharDecX: ;delete char in buf
       cmp      word [.i],0
       jnz      .SaveCharD
       stc
       ret
.SaveCharD:
       dec      word [.i]
       clc
       ret
 
.SaveCharReset:
       xor      eax,eax
       mov      dword [.i], eax
       ret
 
 
.SaveChar:
       test     al,al
       jnz      .work1
       mov      ax,word [.iTop]
       mov      [.i],word ax
       xor      ax,ax
.work1:
 
       mov      bx,word .EnteredString
       add      bx,word [.i]
 
       macro    check_if_i_itop_eqa {
       local    .ok
       push     ax
       mov      ax, word [.i]
       cmp      ax,word [.iTop]
       jz       .ok
       dec      word [.iTop]
.ok:
       pop      ax
       inc      word [.i]
       inc      word [.iTop]
       }
 
       check_if_i_itop_eqa
 
       mov      [bx],byte al
 
       test     al,al
       jnz      .work
 
       xor      eax,eax
       mov      dword [.i], eax
 
.work:
 
       mov      ax,word [.iTop] ;%
       cmp      ax,MAX_SIZE_FOR_ENTERED_WORD
       jb       .okExit
 
       xor      eax,eax
       mov      dword [.i], eax
;IT ERROR___________________________!
       stc
       ret
.okExit:
       mov      ax,word .EnteredString
       clc
       ret
 
.posToStartCursor dd 0
 
.i dw 0
.iTop dw 0
.EnteredString rb MAX_SIZE_FOR_ENTERED_WORD
db 0
 
 
;-----------
.GetKey:
mov word ax,[fs:0+041ah]
mov word bx,[fs:0+041ch]
.wait_kbd:
       call     Clock ;inc\clock.asm
       hlt
cmp word bx,[fs:0+041ch]
       jz       .wait_kbd
mov word ax,[fs:0+bx+0400h]
mov word bx,[fs:0+041ch]
mov word [fs:0+041ah],bx
       ret
;-----------
DecX_replace:
       call     GetPos
       test     eax,eax
       jz       .ok
       dec      eax
       call     SetPos
.ok:
       ret
 
IncX_replace:
       call     GetPos
       cmp      eax,dword 80*24
       jz       .ok
       inc      eax
       call     SetPos
.ok:
       ret
 
 
 
 
;-----------
SetPos:
       mov      dword [PrintToEmdStr.cursor],eax
       ret
 
GetPos:
       mov      eax, dword [PrintToEmdStr.cursor]
       ret
 
GetPosX:
.l1:
       cmp      eax,dword 80
       jae      .notAb80
       ret
.notAb80:
       sub      eax,dword 80
       jmp      .l1
 
 
SetColor:
       mov      byte [PrintToEmdStr.Color],al
       ret
 
PrintToEmd_ASCII_Char:
       mov      byte [.Char],al
       mov      edi,dword [VideoBufMemory]
       mov      eax,dword [PrintToEmdStr.cursor]
       shl      eax,1
       add      edi,eax
       mov      ah,byte [PrintToEmdStr.Color]
       inc      dword [PrintToEmdStr.cursor]
       cmp      dword [PrintToEmdStr.cursor],CHAR_ON_LINE*24
       jnz      .pageVideoOk
 
       call     shiftPage ;----
       mov      [PrintToEmdStr.cursor],dword CHAR_ON_LINE*23
       sub      edi,dword 80*2
.pageVideoOk:
       mov      al,byte [.Char]
       mov      [edi],word ax
 
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
       ret      ;----Exit
.Char db 0
 
PrintToEmdStrSize:
 
       add      esi,ecx
       mov      byte [esi],0
       sub      esi,ecx
 
PrintToEmdStr:
       mov      edi,dword [VideoBufMemory]
       mov      eax,dword [.cursor]
       shl      eax,1
       add      edi,eax
       mov      ah,byte [.Color]
.display:
       cmp      dword [.cursor],CHAR_ON_LINE*24
       jnz      .pageVideoOk
 
       call     shiftPage ;----
 
       mov      [.cursor],dword CHAR_ON_LINE*23
       mov      edi,dword [VideoBufMemory]
.pageVideoOk:
       mov      al,byte [esi]
       test     al,al
       jnz      .ok
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
       ret      ;----Exit
.ok:
       inc      dword [.cursor]
       mov      [edi],word ax
       inc      esi
       add      edi,dword 2
       jmp      .display
 
.cursor dd 0 ;current pos
.Color db 7
;------------
 
SetcursorBios:
 
       cmp      byte [.fVisible],0
       jnz      .work
       ret
.work:
       pusha
       call     GetPos
       xor      dx,dx
.l1:
       test     eax,eax
       jz       .ok
       cmp      eax,dword 80
       jb       .ok
       sub      eax,dword 80
       inc      dh
       jmp      .l1
.ok:
       mov      dl,al
 
 
       cmp      [VideoMode],dword 3
       jz       .okMode
 
       mov      [y],dh
       mov      [x],dl
 
       popa
       ret
.okMode:
 
       mov      ah,02h ;- bios servis
       mov      bh,0
; mov dh,25
; mov dl,25
       int      10h
       popa
 
       ret
.fVisible db 1
 
 
shiftPage:
       .DUBLE_SIZE = CHAR_ON_LINE*2
 
       mov      dword [.saveRegs],esi
       mov      dword [.saveRegs+4],eax
       mov      dword [.saveRegs+8],ecx
 
       mov      esi,dword [VideoBufMemory]
       mov      ecx,CHAR_ON_LINE*24
.upLine:
       mov      ax,word [esi+.DUBLE_SIZE]
       mov      word [esi],ax
       add      esi,dword 2
       dec      ecx
       jnz      .upLine
       mov      ecx,CHAR_ON_LINE
       mov      ax,0x0720
.lastLine:
       mov      word [esi],ax
       add      esi,dword 2
       dec      ecx
       jnz      .lastLine
 
       mov      esi,dword [.saveRegs]
       mov      eax,dword [.saveRegs+4]
       mov      ecx,dword [.saveRegs+8]
 
       ret
.saveRegs dd 0,0,0
 
 
;edi = ptr,ecx=size eax=value
FillMem:
.l1:
       mov      dword [edi],eax
       add      edi,4
       dec      ecx
       jnz      .l1
       ret
 
RestorePos:
       mov      eax,dword [SavePos.pos]
       call     SetPos
       ret
SavePos:
       call     GetPos
       mov      dword [.pos],eax
       ret
.pos dd 0
 
 
       macro    PrintSpaces10 {
       mov      eax, 0x007200720
       mov      ecx,dword 5
       call     FillVideoPage
       }
 
 
 
; eax = value
; edx = cursor to start user string
PrintNumOfFindes:
       cmp      ecx,dword 0
       jnz      .work
       call     SavePos
       add      edx,dword 80
       PrintSpaces10
       jmp      .exit
 
.work:
       mov      ecx,eax
       call     SavePos
 
       add      edx,80
       mov      eax,edx
       call     SetPos
 
       mov      eax,ecx
       call     Bin2AsciiDec ;esi=str
 CrrctEsiFrFrstZrPrnt
;       call     PrintToEmdStr
 
.exit:
       call     RestorePos
       call     SetcursorBios
       mov      esi,dword [VideoBufMemory]
       call     DrawPage
       ret
 
 
;eax=value , edx = pos(like cursor),ecx = size
FillVideoPage:
       mov      esi,dword [VideoBufMemory]
       shl      edx,1
       add      esi,edx
.l1:
       mov      [esi],eax
       add      esi,4
       dec      ecx
       jnz      .l1
       ret
 
 
spacesString db 32,32,32,32,32,32,32,32,32,32,0
 
;EOF
