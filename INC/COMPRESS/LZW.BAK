;lzw.asm
 
 
 
;ecx=size
;esi=ptr of arh
;edi=ptr to unpack data free mem
;ebx=ptr to temp work buff
 
 
LZW_unpack:
 
       MAX_SIZE_READ_BUF=2200
 
       mov      [.sizeDataCompressed], ecx
       mov      [.ptrDataCompressed], esi
       mov      [.ptrDataUnCompressed], edi
       mov      [.ptrTempBuf], ebx
call .Unpack
 
 
ret
 
.sizeDataCompressed dd 0
.ptrDataCompressed dd 0
.ptrDataUnCompressed dd 0
.ptrTempBuf dd 0
 
.Unpack:
 
;---------------------------------------------------------[stage#2]
;Decompress - decompresses data compressed by Lempel-Ziv Welch method.
; BX:AX - Pointer to temporary buffer (17K min.).
; DX:CX - Pointer to compressed data.
; DI:SI - Pointer to buffer to decompress.
; Exit: AX - size of decompressed data.
       mov      ax,[.ptrTempBuf]
;       mov      ax, TemporaryBuffer
 
       mov      si,[.ptrDataUnCompressed]
;       mov      si, DataTestForCompress
 
       mov     cx, [.ptrDataCompressed]
;       mov      cx, BufferToDecompressData
 
       call     LZWDecompr
       xor ecx,ecx
       mov      cx,ax
ret
 
MaxCode dw 0
RunCode dw 0
RunningBits dw 0
CodeBuffer dd 0
CurCode dw 0
OldCode dw 0
CurBuffShift dw 0
InputOffs dw 0
InputSeg dw 0
OutPutOffs dw 0
OutPutSeg dw 0
Temp dw 0
DataSize dw 0
OutPutOffs2 dw 0
CodeTable dd 0
PrefixTable dd 0
SymbolTable dd 0
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;[2]
;InputOffs dw 0
;InputSeg dw 0
Temp_Offs dw 0
Temp_seg dw 0
;OutPutSeg dw 0
 
le6a dw 0
le6c dw 0
le6e dw 0
le70 dw 0
le72 dw 0
le74 dw 0
le78 dw 0
le7a_0 dw 0
le7a_2 dw 0
le7a_4 dw 0
le7a_6 dw 0
le82a dw 0
le82b dw 0
;OutPutOffs2 dw 0
 
le76byte db 0
le77byte db 0
 
 
 
 
OutByte: ;macro
       mov      byte [ bp],al
       inc      bp
       ret
;OutByte: ;end;endm
 
;Decompress - decompresses data compressed by Lempel-Ziv Welch method.
; BX:AX - Pointer to temporary buffer (17K min.).
; DX:CX - Pointer to compressed data.
; DI:SI - Pointer to buffer to decompress.
; Exit: AX - size of decompressed data.
 
LZWDecompr :
       push     bp
 
       mov      [Temp_Offs], ax
       mov      [Temp_seg], bx
       mov      [InputOffs], cx
       mov      [InputSeg], dx
       mov      bp, si
       mov      [OutPutOffs2],si
       mov      [OutPutSeg], di
 
       call     LZWDecomp
 
       mov      ax,bp
       sub      ax,[OutPutOffs2]
       pop      bp
 
       ret
 
LZWDecomp :
       push     si
       push     di
       mov      [le72],0
       mov      [le78],9
       mov      [le70],102h
       mov      [le74],200h
       xor      ax,ax
       mov      [le6a],ax
       mov      [le6c],ax
       mov      [le6e],ax
       mov      [le76byte],al
       mov      [le77byte],al
       mov      [le82a],ax
       mov      [le82b],ax
       mov      [le7a_0],1FFh
       mov      [le7a_2],3FFh
       mov      [le7a_4],7FFh
       mov      [le7a_6],0FFFh
L1_01:
 call GetNextCode
       cmp      ax,101h
       jnz      L1_02
       jmp      L1_end
L1_02:
 cmp ax,100h
       jnz      L1_03
       call     InitTable
       call     GetNextCode
       mov      [le6a],ax
       mov      [le6c],ax
       mov      [le77byte],al
       mov      [le76byte],al
       mov      al,[le77byte]
       call     OutByte
       jmp      L1_01
L1_03:
 mov [le6a],ax
       mov      [le6e],ax
       cmp      ax,[le70]
       jb       L1_04
       mov      ax,[le6c]
       mov      [le6a],ax
       mov      al,[le76byte]
       push     ax
       inc      [le72]
 
L1_04:
cmp [le6a],0ffh
       jbe      L1_05
       mov      si,word [Temp_Offs]
       mov      bx,[le6a]
       shl      bx,1
       add      bx,[le6a]
       mov      al,byte [ bx+si+2]
       push     ax
       inc      [le72]
       mov      ax,word [bx+si]
       mov      [le6a],ax
       jmp      L1_04
L1_05:
 mov ax,[le6a]
       mov      [le76byte],al
       mov      [le77byte],al
       push     ax
       inc      [le72]
       mov      cx,[le72]
       jcxz     L1_07
L1_06:
pop ax
       call     OutByte
       loop     L1_06
L1_07:
mov [le72],0
       call     AddInTable
       mov      ax,[le6e]
       mov      [le6c],ax
       mov      bx,[le70]
       cmp      bx,[le74]
       jl       L1_08
       cmp      byte [ le78],0ch ;ds
       jz       L1_08
       inc      byte [ le78] ;ds
       shl      [le74],1
L1_08:
jmp L1_01
L1_end:
pop di
       pop      si
       ret
 
InitTable :
       mov      byte [ le78],9 ;ds
       mov      [le74],200h
       mov      [le70],102h
       ret
 
GetNextCode :
       mov      bx,[le82a]
       mov      ax,[le82b]
       add      bx,[le78]
       adc      ax,0
       xchg     bx,[le82a]
       xchg     ax,[le82b]
       mov      cx,bx
       and      cx,7 ;!!!!!
       shr      ax,1
       rcr      bx,1
       shr      ax,1
       rcr      bx,1
       shr      ax,1
       rcr      bx,1
       mov      si,word [InputOffs]
       mov      ax,word [bx+si]
       mov      dl,byte [ bx+si+2]
       or       cx,cx
       jz       GetCode2
GetCode1:
shr dl,1
       rcr      ax,1
       loop     GetCode1
GetCode2:
mov bx,[le78]
       sub      bx,9
       shl      bx,1
       and      ax,[bx+le7a_0]
       ret
 
AddInTable :
       push     si
       mov      bx,[le70]
       shl      bx,1
       add      bx,[le70]
       mov      si,word [Temp_Offs]
       mov      al,[le77byte]
       mov      byte [ bx+si+2],al
       mov      ax,[le6c]
       mov      word [bx+si],ax
       inc      [le70]
       pop      si
       ret
 
 
;EOF
